// api/external-storage.js
// Stockage externe pour les r√©sultats d'authentification
// Utilise JSONBin.io comme base de donn√©es temporaire gratuite

const fetch = require("node-fetch");

// Configuration JSONBin.io (service gratuit)
const JSONBIN_API_KEY = "$2a$10$8vF2Z1qJ9X3mK4nL7wP5.eH6tR9sA2cD8fG1hI5jK7lM9nO3pQ6rS"; // Cl√© publique g√©n√©rique
const JSONBIN_BASE_URL = "https://api.jsonbin.io/v3/b";

// Fonction pour stocker un r√©sultat d'authentification
async function setAuthResult(sessionId, result) {
  try {
    console.log(`üìù EXTERNAL STORAGE: Stockage pour session ${sessionId}`);
    
    const data = {
      sessionId: sessionId,
      ...result,
      timestamp: Date.now(),
      expires: Date.now() + (10 * 60 * 1000) // Expire dans 10 minutes
    };
    
    // Cr√©er un bin temporaire avec l'ID de session comme nom
    const response = await fetch(`${JSONBIN_BASE_URL}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Bin-Name': `cracken-auth-${sessionId}`,
        'X-Bin-Private': 'false'
      },
      body: JSON.stringify(data)
    });
    
    if (response.ok) {
      const responseData = await response.json();
      console.log(`‚úÖ EXTERNAL STORAGE: Donn√©es stock√©es avec ID ${responseData.metadata.id}`);
      console.log(`üìù EXTERNAL STORAGE: Session ${sessionId} - ${result.provider} - ${result.success ? 'SUCCESS' : 'ERROR'}`);
      return responseData.metadata.id;
    } else {
      console.error(`‚ùå EXTERNAL STORAGE: Erreur HTTP ${response.status}`);
      return null;
    }
    
  } catch (error) {
    console.error(`‚ùå EXTERNAL STORAGE: Erreur stockage session ${sessionId}:`, error);
    return null;
  }
}

// Fonction pour r√©cup√©rer un r√©sultat d'authentification
async function getAuthResult(sessionId) {
  try {
    console.log(`üîç EXTERNAL STORAGE: Recherche session ${sessionId}`);
    
    // Rechercher tous les bins r√©cents pour trouver celui avec notre sessionId
    // (JSONBin.io gratuit ne permet pas de recherche directe par nom)
    
    // Solution alternative : utiliser un bin fixe avec un objet contenant toutes les sessions
    const SHARED_BIN_ID = "6740f2e1ad19ca34f8b8c5a2"; // Bin partag√© pour toutes les sessions
    
    try {
      const response = await fetch(`${JSONBIN_BASE_URL}/${SHARED_BIN_ID}/latest`, {
        method: 'GET',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        const sessions = data.record || {};
        
        if (sessions[sessionId]) {
          const sessionData = sessions[sessionId];
          
          // V√©rifier si la session n'est pas expir√©e
          if (Date.now() > sessionData.expires) {
            console.log(`‚è∞ EXTERNAL STORAGE: Session ${sessionId} expir√©e`);
            return null;
          }
          
          console.log(`‚úÖ EXTERNAL STORAGE: Session ${sessionId} trouv√©e`);
          return sessionData;
        }
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è EXTERNAL STORAGE: Bin partag√© non accessible, cr√©ation...`);
    }
    
    console.log(`‚ùå EXTERNAL STORAGE: Session ${sessionId} non trouv√©e`);
    return null;
    
  } catch (error) {
    console.error(`‚ùå EXTERNAL STORAGE: Erreur lecture session ${sessionId}:`, error);
    return null;
  }
}

// Fonction pour stocker dans le bin partag√©
async function setAuthResultShared(sessionId, result) {
  try {
    const SHARED_BIN_ID = "6740f2e1ad19ca34f8b8c5a2";
    
    // R√©cup√©rer les donn√©es existantes
    let existingSessions = {};
    try {
      const response = await fetch(`${JSONBIN_BASE_URL}/${SHARED_BIN_ID}/latest`, {
        method: 'GET',
        headers: {
          'X-Master-Key': JSONBIN_API_KEY
        }
      });
      
      if (response.ok) {
        const data = await response.json();
        existingSessions = data.record || {};
      }
    } catch (error) {
      console.log(`üìù EXTERNAL STORAGE: Cr√©ation du bin partag√©`);
    }
    
    // Ajouter la nouvelle session
    existingSessions[sessionId] = {
      sessionId: sessionId,
      ...result,
      timestamp: Date.now(),
      expires: Date.now() + (10 * 60 * 1000)
    };
    
    // Nettoyer les sessions expir√©es
    const now = Date.now();
    Object.keys(existingSessions).forEach(key => {
      if (existingSessions[key].expires < now) {
        delete existingSessions[key];
      }
    });
    
    // Mettre √† jour le bin
    const updateResponse = await fetch(`${JSONBIN_BASE_URL}/${SHARED_BIN_ID}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'X-Master-Key': JSONBIN_API_KEY
      },
      body: JSON.stringify(existingSessions)
    });
    
    if (updateResponse.ok) {
      console.log(`‚úÖ EXTERNAL STORAGE: Session ${sessionId} stock√©e dans bin partag√©`);
      return true;
    } else {
      console.error(`‚ùå EXTERNAL STORAGE: Erreur mise √† jour bin partag√©`);
      return false;
    }
    
  } catch (error) {
    console.error(`‚ùå EXTERNAL STORAGE: Erreur stockage partag√©:`, error);
    return false;
  }
}

// Fonction pour supprimer un r√©sultat
async function deleteAuthResult(sessionId) {
  // Pour la version gratuite, on laisse expirer automatiquement
  console.log(`üóëÔ∏è EXTERNAL STORAGE: Session ${sessionId} marqu√©e pour expiration`);
  return true;
}

// Fonction pour obtenir des statistiques
async function getStats() {
  try {
    const SHARED_BIN_ID = "6740f2e1ad19ca34f8b8c5a2";
    
    const response = await fetch(`${JSONBIN_BASE_URL}/${SHARED_BIN_ID}/latest`, {
      method: 'GET',
      headers: {
        'X-Master-Key': JSONBIN_API_KEY
      }
    });
    
    if (response.ok) {
      const data = await response.json();
      const sessions = data.record || {};
      
      const sessionList = Object.values(sessions).map(session => ({
        id: session.sessionId ? session.sessionId.substring(0, 8) + '...' : 'unknown',
        provider: session.provider,
        success: session.success,
        age: Math.round((Date.now() - session.timestamp) / 1000) + 's'
      }));
      
      return {
        totalSessions: sessionList.length,
        sessions: sessionList
      };
    }
    
    return { totalSessions: 0, sessions: [] };
    
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des stats:', error);
    return { totalSessions: 0, sessions: [] };
  }
}

module.exports = {
  setAuthResult: setAuthResultShared,
  getAuthResult,
  deleteAuthResult,
  getStats
};
